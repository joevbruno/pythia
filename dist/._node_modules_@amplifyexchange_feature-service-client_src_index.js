import axios from 'axios'
import { FeatureServiceClientError } from './FeatureServiceClientError'
import { requireArg, isNotObjectLiteral } from './util'
import { TIME } from './enums'

export class FeatureFlagService {
  constructor({
    serviceUrl,
    clientKey,
    appName,
    environment = 'default',
    pollForUpdates = true,
    pollingInterval = TIME.FIVE_MINUTES,
    onDataUpdated,
    isolate = false
  }) {
    this.isolate = isolate

    if (!this.isolate) {
      const requiredArgs = [
        { name: 'serviceUrl', value: serviceUrl },
        { name: 'clientKey', value: clientKey },
        { name: 'appName', value: appName }
      ]
      requiredArgs.forEach(requireArg)

      this.context = { environment, appName }
      this.serviceUrl = serviceUrl
      this.clientKey = clientKey
      this.pollingInterval = pollingInterval
      this.http = axios.create()

      if (pollForUpdates && typeof onDataUpdated !== 'function') {
        throw new FeatureServiceClientError('onDataUpdated is required when pollForUpdates is true (default)')
      }

      this.onDataUpdated = onDataUpdated

      this.features = []

      if (pollForUpdates === true) {
        this.startPolling()
      }
    } else {
      import('../mock-data/features.json').then(data => {
        const { toggles: features } = data

        this.features = features
      })
    }
  }

  updateContext(data) {
    if (isNotObjectLiteral(data)) {
      throw new FeatureServiceClientError('Error (updateContext): argument must be an object literal')
    }

    this.context = {
      ...this.context,
      ...data
    }
  }

  startPolling() {
    if (this.isolate) {
      return
    }

    this.polling = setInterval(async () => {
      const stringifiedCachedFeatures = JSON.stringify(this.features)
      const features = await this.fetchToggles()
      const stringifiedResults = JSON.stringify(features)

      if (stringifiedResults !== stringifiedCachedFeatures) {
        this.onDataUpdated(features)
      }
    }, this.pollingInterval)
  }

  stopPolling() {
    if (this.polling) {
      clearInterval(this.polling)
    }
  }

  isEnabled(toggle) {
    const feature = this.features.find(f => f.name === toggle)

    return feature ? feature.enabled : false
  }

  getVariant(toggle) {
    const feature = this.features.find(f => f.name === toggle)

    return feature ? feature.variant : { name: 'disabled' }
  }

  async fetchToggles() {
    if (this.isolate) {
      return this.features
    }

    try {
      const response = await this.http.get(this.serviceUrl, {
        headers: {
          Authorization: this.clientKey
        },
        params: this.context
      })

      const { data: { toggles: features } } = response

      this.features = features

      return features
    } catch (error) {
      throw new FeatureServiceClientError('Error fetching feature toggle data')
    }
  }
}
