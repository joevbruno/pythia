import axios from 'axios'
import { ServiceAuthFailedError } from './errors/ServiceAuthFailedError'
import { DepositError } from './errors/DepositError'
import { WithdrawalError } from './errors/WithdrawalError'
import { CreateDepositTicketError } from './errors/CreateDepositTicketError'
import { ExceedsDailyWithdrawLimitError } from './errors/ExceedsDailyWithdrawLimitError'
import { InsufficientFundsError } from './errors/InsufficientFundsError'
import { GetTicketError } from './errors/GetTicketError'
import { AccountError } from './errors/AccountError'
import { CancelWithdrawalError } from './errors/CancelWithdrawalError'
import { buildHeader } from './utils'

import { MockAxios } from './mocks/axios'
import { MockApex } from './mocks/apex'

export class BankClient {
  constructor({
    url, isolate, _axios, _apex, omsId, operatorId
  }) {
    this.url = url
    this.isolate = String(isolate) === 'true'
    this.omsId = omsId || 1
    this.operatorId = operatorId || 1

    // this is untested don't remove it
    this.axios = _axios || axios

    this.apex = _apex

    if (this.isolate) {
      this.axios = MockAxios
      this.apex = MockApex
    }
  }

  /* Deposit Meta Call */

  async createDeposit({
    exchangeUserId,
    exchangeAccountId,
    amount,
    assetId,
    token
  }) {
    const newTicket = await this.createDepositTicket({ exchangeAccountId, amount, assetId })

    return this.createBankDeposit({
      token,
      exchangeUserId,
      exchangeAccountId,
      exchangeTicketId: newTicket.exchangeTicketId
    })
  }

  async createDepositTicket({ exchangeAccountId, amount, assetId }) {
    const depositRequest = {
      OMSId: this.omsId,
      OperatorId: this.operatorId,
      AccountId: exchangeAccountId,
      AssetId: assetId,
      Amount: amount,
      DepositInfo: ''
    }

    const { result, ticketnumber, requestcode } = await this.apex.CreateDepositTicket(depositRequest)

    if (result === false) {
      throw new CreateDepositTicketError()
    }

    return {
      exchangeTicketId: ticketnumber,
      requestCode: requestcode
    }
  }

  async createWithdrawTicket({
    accountId, productId, amount, templateForm, accountProviderId, templateType
  }) {
    const body = {
      OMSId: this.omsId,
      AccountId: accountId,
      ProductId: productId,
      Amount: amount,
      TemplateForm: JSON.stringify(templateForm),
      TemplateType: templateType,
      AccountProviderId: accountProviderId
    }

    const { result, detail } = await this.apex.CreateWithdrawTicket(body)

    if (result) {
      return Promise.resolve({ result, detail })
    }

    if (detail === 'Insufficient Balance') {
      return Promise.reject(new InsufficientFundsError())
    }

    if (detail === 'Exceeds_Daily_Withdraw_Limit') {
      return Promise.reject(new ExceedsDailyWithdrawLimitError())
    }

    return Promise.reject(new WithdrawalError('Unable to create withdraw ticket'))
  }

  async cancelWithdrawal({
    token,
    exchangeUserId,
    exchangeAccountId,
    requestCode
  }) {
    try {
      const { headers } = buildHeader(token)
      const data = {
        exchangeUserId,
        exchangeAccountId,
        requestCode
      }

      const response = await this.axios.delete(`${this.url}/withdraws`, { data, headers })

      return response.status === 204
    } catch (error) {
      if (error.status === 401) {
        throw new ServiceAuthFailedError()
      }

      throw new CancelWithdrawalError(error.message)
    }
  }

  async getDepositTicket({ requestCode, ticketId, accountId }) {
    const body = {
      RequestCode: requestCode,
      TicketId: ticketId,
      AccountId: accountId,
      OMSId: this.omsId

    }
    const response = await this.apex.RPCPromise('GetDepositTicket', body)
    const ticket = JSON.parse(response.o)

    if (ticket.result === false) {
      return Promise.reject(new GetTicketError())
    }

    return ticket
  }

  async getWithdrawTicket({ requestCode, accountId }) {
    const body = {
      RequestCode: requestCode,
      AccountId: accountId,
      OMSId: this.omsId

    }
    const response = await this.apex.RPCPromise('GetWithdrawTicket', body)
    const ticket = JSON.parse(response.o)

    if (ticket.result === false) {
      return Promise.reject(new GetTicketError())
    }

    return ticket
  }

  async createBankDeposit({
    token,
    exchangeTicketId,
    exchangeUserId,
    exchangeAccountId
  }) {
    try {
      const headers = buildHeader(token)
      const body = {
        exchangeUserId,
        exchangeAccountId,
        exchangeTicketId
      }

      const response = await this.axios.post(`${this.url}/deposits`, body, headers)

      if (response.status === 201) {
        return Promise.resolve(response.data)
      }

      return Promise.reject(new DepositError())
    } catch (error) {
      if (error.status === 401) {
        return Promise.reject(new ServiceAuthFailedError())
      }

      return Promise.reject(new DepositError(error.message))
    }
  }

  async createBankWithdrawal({
    token,
    bankingAccountId,
    exchangeAccountId,
    exchangeUserId,
    requestCode,
    reference
  }) {
    try {
      const headers = buildHeader(token)
      const body = {
        bankingAccountId,
        exchangeAccountId,
        exchangeUserId,
        requestCode
      }

      if (reference) {
        body.reference = reference
      }

      const response = await this.axios.post(`${this.url}/withdraws`, body, headers)

      if (response.status === 201) {
        return Promise.resolve(response.data)
      }

      return Promise.reject(new WithdrawalError())
    } catch (error) {
      if (error.status === 401) return Promise.reject(new ServiceAuthFailedError())
      return Promise.reject(new WithdrawalError(error.message))
    }
  }

  /* Account Management */

  async addAccount({
    token,
    exchangeUserId,
    bankName,
    bankCountry,
    iban,
    currency,
    label,
    bic,
    fullName,
    address,
    country
  }) {
    try {
      const headers = buildHeader(token)
      const body = {
        exchangeUserId,
        fullName,
        country,
        bankName,
        bankCountry,
        iban,
        currency,
        label,
        bic,
        address
      }

      const response = await this.axios.post(`${this.url}/accounts`, body, headers)

      if (response.status === 201) {
        return Promise.resolve(response.data)
      }

      return Promise.reject(new AccountError())
    } catch (error) {
      if (error.status === 401) {
        return Promise.reject(new ServiceAuthFailedError())
      }

      return Promise.reject(new AccountError(error.message))
    }
  }

  async getAccounts({ token, exchangeUserId }) {
    try {
      const headers = buildHeader(token)
      const response = await this.axios.get(`${this.url}/accounts?exchangeUserId=${exchangeUserId}`, headers)

      if (response.status === 200) {
        return Promise.resolve(response.data)
      }

      return Promise.reject(new AccountError())
    } catch (error) {
      if (error.status === 401) {
        return Promise.reject(new ServiceAuthFailedError())
      }

      return Promise.reject(new AccountError(error.message))
    }
  }

  async deleteAccount({ token, exchangeUserId, bankAccountId }) {
    try {
      const headers = buildHeader(token)
      const body = {
        exchangeUserId
      }

      const response = await this.axios.delete(`${this.url}/accounts/${bankAccountId}`, { data: body, ...headers })

      if (response.status === 204) {
        return Promise.resolve(response.data)
      }

      return Promise.reject(new AccountError())
    } catch (error) {
      if (error.status === 401) {
        return Promise.reject(new ServiceAuthFailedError())
      }

      return Promise.reject(new AccountError(error.message))
    }
  }
}
