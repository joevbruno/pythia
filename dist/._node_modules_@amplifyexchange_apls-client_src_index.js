import axios from 'axios'
import { HttpStatus } from './enums'
import { isNotEmpty } from './utils'
import {
  resolutionParam, fromParam, toParam, limitParam, orderParam
} from './utils/plParamHelpers'
import { ServiceAuthFailedError } from './errors/ServiceAuthFailedError'
import { ProfileMapper } from './mappers/profile'
import { MockAxios } from './mocks/axios'

function barMapper(el) {
  return {
    time: Date.parse(el.timestamp),
    close: Number(el.value)
  }
}

export class AplsClient {
  constructor({ url, isolate, _axios }) {
    this.url = url
    this.isolate = String(isolate) === 'true'

    // this is untested don't remove it
    this.axios = _axios || axios

    if (this.isolate) {
      this.axios = MockAxios
    }
  }

  static getDefaultHeaders(token) {
    if (!token) {
      throw new TypeError('token is invalid')
    }

    return {
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    }
  }

  async authenticate(userId, secret) {
    try {
      const response = await this.axios.post(`${this.url}/auth`, {
        userId,
        profitLossSecret: secret
      },
      {
        headers: {
          'Content-Type': 'application/json'
        }
      })

      if (response.status === 200) {
        return Promise.resolve(response.data)
      }

      return Promise.reject(new ServiceAuthFailedError())
    } catch (error) {
      return Promise.reject(new ServiceAuthFailedError(error.message))
    }
  }

  async getProductProfile(symbol) {
    const results = await Promise.all([
      this.axios.get(`${this.url}/currency/${symbol}`),
      this.axios.get(`${this.url}/quotes?symbol=${symbol.toLowerCase()}&limit=1`)
    ])

    const profileResponse = results[0]
    const quoteResponse = results[1]

    if (profileResponse.status === 200 && quoteResponse.status === 200) {
      const profile = ProfileMapper.map(profileResponse.data[symbol.toUpperCase()], quoteResponse.data[0])

      return Promise.resolve(profile)
    }

    return Promise.reject(new Error())
  }

  async getPortfolio(accountId, token) {
    const response = await this.axios.get(`${this.url}/portfolio/${accountId}`, AplsClient.getDefaultHeaders(token))

    if (response.status === HttpStatus.OK) {
      return Promise.resolve(response.data)
    }

    return Promise.reject(new Error())
  }

  async getPrices() {
    const response = await this.axios.get(`${this.url}/quotes/recent`)

    if (response.status === HttpStatus.OK) {
      return Promise.resolve(response.data)
    }

    return Promise.reject(new Error())
  }

  async getProductInfo() {
    try {
      const prices = await this.getPrices()

      const info = prices.map(p => ({
        symbol: p.symbol.toUpperCase(),
        marketCap: isNotEmpty(p.usd_market_cap) ? p.usd_market_cap : 0,
        circulatingSupply: isNotEmpty(p.circulating_supply) ? p.circulating_supply : 0
      }))

      const productInfo = info.reduce((acc, entry) => {
        acc[entry.symbol] = entry

        return acc
      }, {})

      return Promise.resolve({ name: 'productInfo', productInfo })
    } catch (error) {
      return Promise.resolve({ name: 'productInfo', productInfo: {} })
    }
  }

  async getPortfolioChart({
    accountId, from, to, limit, resolution, token
  }) {
    let url = `${this.url}/portfolio_chart/${accountId}?`
    url += resolutionParam(resolution)
    url += fromParam(from)
    url += toParam(to)
    url += orderParam('ASC')
    url += limitParam(limit)

    const response = await this.axios.get(url, AplsClient.getDefaultHeaders(token))

    const { data } = response

    return Promise.resolve(data.map(barMapper))
  }

  async getMarketHistories({ pair, to, from }) {
    const response = await this.axios.get(`${this.url}/market_chart?pair=${pair.toLowerCase()}&to=${to}&from=${from}`)

    if (response.status === HttpStatus.OK) {
      const bars = response.data.map(tick => ({
        time: new Date(tick.timestamp),
        low: tick.low_value,
        high: tick.high_value,
        open: tick.open_value,
        close: tick.close_value,
        volume: tick.volume_value

      }))

      return Promise.resolve(bars)
    }

    return Promise.reject(new Error())
  }
}
